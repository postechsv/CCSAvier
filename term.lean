/-----------------------------------------------------------------------/
/-                                                                     -/
/-   Cminor Semantics in Lean 4                                        -/
/-                                                                     -/
/-   Authors: Byoungho Son, POSTECH, South Korea         -/
/-                                                                     -/
/-   © 2025. This work is a draft and is not currently licensed.       -/
/-   No permission is granted to copy, use, or distribute this file.   -/
/-                                                                     -/
/-----------------------------------------------------------------------/

namespace MaudeTest

--- Definition of Terms as the free algebra generated by X
--- You define your syntax manually here
--- Order Sorted Algebras must be defined as mutually inductive types
inductive Term (X: Type) where
  | var : X → Term X --- variable
  | op_f : Term X → Term X
  | op_g : Term X → Term X → Term X
  ---| op (f : sig.Symbol) : Vector (Term X) (sig.arity f) → Term sig X

def t1 := Term.var 0 --- x0
def t2 := Term.op_f (Term.var 0) --- f(x0)
def t3 := Term.op_g (Term.op_f (Term.var 0)) (Term.op_f (Term.var 1)) --- g(f(x0), f(x1))

--- homomorphic extension
def Term.subst (t: Term X) (f: X → Term X) : Term X :=
  match t with
  | var x => f x
  | op_f t' => op_f (t'.subst f)
  | op_g t1 t2 => op_g (t1.subst f) (t2.subst f)

#eval t2
#eval t3.subst (λ x => match x with | 0 => t2 | _ => Term.var x)

--- Definition of Basic Patterns as pairs (Term, Prop)
structure BPat (X: Type) where
  term : Term X
  guard : Prop

--- Definition of Patterns as lists of Basic Patterns
abbrev Pattern (X: Type):= List (BPat X)

end MaudeTest

namespace Maude
/-- A first-order signature: each symbol `f` has a finite arity. -/
structure Signature where
  Symbol : Type
  arity  : Symbol → Nat

/-- Terms over a signature `Σ` with variables from `X`. -/
inductive Term (sig : Signature) (X : Type) : Type where
  | var : X → Term sig X
  | op  : (f : sig.Symbol) →
          (Fin (sig.arity f) → Term sig X) →  -- children indexed by positions
          Term sig X
---deriving Repr

--- Definition of Basic Patterns as pairs (Term, Prop)
structure BPat (sig : Signature) (X: Type) where
  term : Term sig X
  guard : Prop

--- Definition of Patterns as lists of Basic Patterns
abbrev Pattern (sig : Signature) (X: Type):= List (BPat sig X)

open Term

variable {sig : Signature} {X : Type}

/-- Fold over terms: give an algebra for variables and for each symbol. -/
def fold {α : Sort _}
    (algVar : X → α)
    (algOp  : ∀ f : sig.Symbol, (Fin (sig.arity f) → α) → α)
    : Term sig X → α
  | var x     => algVar x
  | op f args => algOp f (fun i => fold algVar algOp (args i))

/-- Rename variables. -/
def mapVars {Y} (g : X → Y) : Term sig X → Term sig Y :=
  fold (fun x => Term.var (g x)) (fun f cs => Term.op f cs)

/-- Substitute variables by terms. -/
def bind {Y} (σ : X → Term sig Y) : Term sig X → Term sig Y :=
  fold σ (fun f cs => Term.op f cs)

/-- `pure` and `bind` give `Term Σ` a monad over the variable type. -/
instance : Pure (Term sig) where
  pure := Term.var

instance : Bind (Term sig) where
  bind t σ := bind σ t

/-- A Σ-algebra on a carrier `A`. -/
structure Algebra (sig : Signature) (A : Type) where
  (interp : ∀ f : sig.Symbol, (Fin (sig.arity f) → A) → A)

/-- Evaluate a term given a variable assignment `ρ : X → A`. -/
def eval {A} (Aalg : Algebra sig A) (ρ : X → A) : Term sig X → A :=
  fold ρ (fun f cs => Aalg.interp f cs)




/-- Some examples --/
inductive Sym | zero | succ | add
open Sym

def SigNat : Signature where
  Symbol := Sym
  arity
  | zero => 0
  | succ => 1
  | add  => 2

-- A sample term: add (succ x) zero
def xVar : Nat := 0
def t : Term SigNat Nat :=
  Term.op add
    (fun
      | ⟨0, _⟩ => Term.op succ (fun _ => Term.var xVar)
      | ⟨1, _⟩ => Term.op zero (fun i => nomatch i))

-- Interpret symbols in `Nat`
def NatAlg : Algebra SigNat Nat where
  interp
  | zero, _ => 0
  | succ, cs => Nat.succ (cs ⟨0, by decide⟩)
  | add,  cs => (cs ⟨0, by decide⟩) + (cs ⟨1, by decide⟩)

#eval eval NatAlg (fun x => x + 10) t  -- (succ (x+10)) + 0 = 11

end Maude
