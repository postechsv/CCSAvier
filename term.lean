--   Deep Embedding of (Unsorted) Maude Terms in Lean 4
--
--   Authors: Byoungho Son, POSTECH, South Korea
--
--   © 2025. This work is a draft and is not currently licensed.
--   No permission is granted to copy, use, or distribute this file.

namespace Term
/- Unsorted first-order signature -/
structure Signature where
  Symbol : Nat → Type

/- Term: free algebra generated by a set X of variables -/
inductive Term (sig : Signature) (X : Type) : Type where
  | var : X → Term sig X
  | op  : {n : Nat} → (f : sig.Symbol n) → (Fin n → Term sig X) → Term sig X


variable {sig : Signature} {X Y Z: Type}

/- Fold over terms -/
def fold {α : Sort _}
    (algVar : X → α)
    (algOp  : ∀ {n}, (f : sig.Symbol n) → (Fin n → α) → α)
    : Term sig X → α
  | .var x       => algVar x
  | .op f args   => algOp f (fun i => fold algVar algOp (args i))

/- Variable Renaming -/
def rename (g : X → Y) : Term sig X → Term sig Y :=
  fold (fun x => Term.var (g x)) (fun f cs => Term.op f cs)

/- Substitution over terms -/
def subst (σ : X → Term sig Y) : Term sig X → Term sig Y :=
  fold σ (fun f cs => Term.op f cs)

/- `Term Σ` is a free monad over the variables -/
instance : Monad (Term sig) where
  pure := Term.var
  bind t σ := subst σ t

/- A Σ-algebra on a carrier `A` -/
structure Algebra (sig : Signature) (A : Type) : Type where
  interp : ∀ {n}, sig.Symbol n → (Fin n → A) → A

/- Evaluation function: homomorphic extension
   of a valuation `ρ : X → A` to the free monad -/
def eval {A} (Aalg : Algebra sig A) (ρ : X → A) : Term sig X → A :=
  fold ρ (fun f cs => Aalg.interp f cs)


def Matches (t : Term sig X) (t' : Term sig Y) : Prop :=
  ∃ σ : X → Term sig Y, subst σ t = t'


-- Basic lemmas

/- Reflexivity (with same variable set): use the identity substitution. -/
-- theorem Matches.refl (t : Term sig X) : Matches t t :=
--   ⟨(fun x => Term.var x), by
     -- `subst (fun x => var x) t = t`
     -- follows from your `fold`-based definition
     -- (induction on `t` if needed)
     -- sketch:
    --  induction t with
    --  | var x      => rfl
    --  | op f args ih =>
    --        simp [subst, fold]
    --        funext i
    --        exact ih i
end Term


namespace PrettyTerm
open Term
open Term.Term

class ToStringSym (sig : Signature) where
  symToString : {n : Nat} → sig.Symbol n → String

@[inline] private def finFunToList {n : Nat} (f : Fin n → String) : List String :=
  List.ofFn (fun i : Fin n => f i)

/-- String printer for terms, using the bundled symbol printer. -/
def term2string
  [ToString X] [ToStringSym sig] (t: Term sig X) : String :=
  Term.fold (sig:=sig) (X:=X)
    (fun x => s!"X_{toString x}")
    (fun f cs =>
      let parts := finFunToList (fun i => cs i)
      let args  := String.intercalate ", " parts
      s!"{ToStringSym.symToString f}({args})")
    t


/- ToString instance for Term -/
instance [ToString X] [ToStringSym sig] : ToString (Term sig X) where
  toString := term2string

/- Repr instance for Term -/
instance [ToString X] [ToStringSym sig] : Repr (Term sig X) where
  reprPrec t _ := .text (term2string t)
end PrettyTerm



namespace TermExample
open Term
open PrettyTerm

/- Some examples -/
inductive Sym : Nat → Type
| zero  : Sym 0
| succ  : Sym 1
| add   : Sym 2

open Sym

def sig_nat : Signature := { Symbol := Sym }

instance : ToStringSym sig_nat where
  symToString
  | zero => "zero"
  | succ => "succ"
  | add  => "add"

/--- Below are codes for pretty printing ---/
def op0  (f : sig.Symbol 0)                 : Term sig X := .op f (fun i => nomatch i)
def op1  (f : sig.Symbol 1) (a : Term sig X)  : Term sig X := .op f (fun | ⟨0, _⟩ => a)
def op2  (f : sig.Symbol 2) (a b : Term sig X): Term sig X :=
  .op f (fun | ⟨0, _⟩ => a | ⟨1, _⟩ => b)
-- etc.

notation:max f:100 "(" ")"          => op0 f
notation:max f:100 "(" a ")"        => op1 f a
notation:max f:100 "(" a "," b ")"  => op2 f a b

def zero' : Term sig_nat X := op0 zero
def zero''  : Term sig_nat X := zero()
def add_one_zero : Term sig_nat Nat := add(succ(zero()), zero())
def add_one_x : Term sig_nat Nat := add(succ(zero()), .var 0)

#eval add_one_zero -- add(succ(zero()), zero())
#eval add_one_x -- add(succ(zero()), X_0)

#eval (subst (sig:=sig_nat) (X:=Nat) (Y:=Nat)
      (fun x:Nat => succ(.var x)) add_one_zero)
#eval (subst (sig:=sig_nat) (fun x:Nat => succ(.var x)) add_one_zero)
#eval (subst (fun x:Nat => succ(.var x) : Nat → Term sig_nat Nat) add_one_zero)
--- #eval (subst (fun x:Nat => succ(Term.var x)) add_one_zero) // does not work

-- add(succ(zero()), X_0) ---> add(succ(zero()), succ(X_0))
#eval ((subst (sig:=sig_nat) (fun x => succ(.var x))) add_one_x)

-- add(succ(zero()), X_0) ---> add(succ(zero()), succ(X_1))
#eval ((subst (sig:=sig_nat) (fun x:Nat => succ(.var (x + 1)))) add_one_x)

-- Interpret symbols in `Nat`
-- def NatAlg : Algebra SigNat Nat where
--   interp
--   | zero, _ => 0
--   | succ, cs => Nat.succ (cs ⟨0, by decide⟩)
--   | add,  cs => (cs ⟨0, by decide⟩) + (cs ⟨1, by decide⟩)

-- #eval eval NatAlg (fun x => x + 10) t  -- (succ (x+10)) + 0 = 11

end TermExample



namespace Pattern
open Term
--- Definition of Basic Patterns as pairs (Term, Prop)
structure BPat (sig : Signature) (X: Type) where
  term : Term sig X
  guard : Prop

--- Definition of Patterns as lists of Basic Patterns
abbrev Pattern (sig : Signature) (X: Type):= List (BPat sig X)
end Pattern
